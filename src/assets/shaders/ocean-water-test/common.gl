//#define APPLY_HEIGHT_FOG

const float PI = 3.1415927f;

// CAM CONTROLS
const float autoRotSpeed = 0.05;
const float camRotSpeed = 1.4;
const float camYSpeed = 3.5;
const vec2 baseCamMove = vec2(2.5, 1.3);
const vec2 minMaxCamY = vec2(.5, 6.);

// RAYMARCHING
const int STEPS = 200;
const int STEPS_GROUND = 50;

// WATER PARAMS
const int numWaves = 60;
const float oceanHeight = 0.2;
const float waveBaseHeight = 0.5; // how high the water must minimally be (min dist from floor)
const float waveMaxAmplitude = 0.35f;
const vec3 waterCol = vec3(0.15,0.5,0.75);
const float waterAbsorp = 0.7;
const vec3 subsurfCol = waterCol * vec3(1.3,1.5,1.1); //vec3(0.3f, 0.8f, 0.65f);

// MATS & LIGHT
const int MAT_OCEAN = 0;
const int MAT_GROUND = 1;
const vec3 ld = normalize(vec3(-1,-1,-2));

// FOG
#ifdef APPLY_HEIGHT_FOG
const vec3 fogColor = vec3(0.8);
const float fogHeightExtinction = 2.5;
const float fogDistExtinction = .125;
const float fogIntensity = .5;
#endif

float saturate(float v) { return clamp(v, 0., 1.); }

#define T_MOUSE_ROT ivec2(0,0)


// from nojima: https://www.shadertoy.com/view/ttc3zr
uint murmurHash11(uint src) {
    const uint M = 0x5bd1e995u;
    uint h = 1190494759u;
    src *= M; src ^= src>>24u; src *= M;
    h *= M; h ^= src;
    h ^= h>>13u; h *= M; h ^= h>>15u;
    return h;
}
float hash11(float src) {
    uint h = murmurHash11(floatBitsToUint(src));
    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;
}

float SingleWaveHeight(vec2 uv, vec2 dir, float speed, float ampl, float time)
{
    float d = dot(uv,dir);
    float ph = d * 10.f + time * speed; //sin(uv.x * 4.f + iTime) * sin(uv.y * 3.f + iTime);
    float h = (sin(ph) * 0.5f + 0.5f); // [0,1]
    h = pow(h, 2.f); // apply some steepness
    h = h * 2. - 1.; // [-1,1]
    return h * ampl;
}

float WaveHeight(vec2 uv, float time, int num)
{
    uv *= 1.6f;
    
    float h = 0.f;
    float w = 1.f;
    float tw = 0.f;
    float s = 1.f;
    const float phBase = 0.2f;
    float deriv1 = 0.f; float deriv2 = 0.f;
    for(int i = 0; i < num; i++) {
        float rand = hash11(float(i)) * 2.f - 1.f;
        float dirMaxDiffer = float(i) / float(numWaves-1);
        dirMaxDiffer = pow(dirMaxDiffer, 1.f) * 2.f * PI;
        float ph = phBase + rand * .75 * PI; //(rand * dirMaxDiffer);
        vec2 dir = vec2(sin(ph), cos(ph));
        h += SingleWaveHeight(uv, dir, 1.f + s * 0.05f, w, time);
        tw += w;
        const float scale = 1.0812f;
        w /= scale;
        uv *= scale;
        s *= scale;
    }
    
    h /= tw; // [0,1]
    h = waveBaseHeight + waveMaxAmplitude * h;
    return h;
}

void RORD(vec2 uv, out vec3 ro, out vec3 rd, float time, sampler2D dataBuffer) {
    //float rotPh;
    //float y;
    //if(iMouse.z > 0.) {
    //    rotPh = -iMouse.x * 0.01;
    //    y = 4. - iMouse.y * 0.005;
    //}
    //else {
    //    rotPh = 2.5f + time * 0.05f;
    //    y = 1.3;
    //}
    vec2 camMove = texelFetch(dataBuffer, T_MOUSE_ROT, 0).xy;
    float rotPh = camMove.x;
    float y = camMove.y;
    
    float rad = 1.6; //1.45f; //smoothstep(0.f, 6.f, time - 0.5f) * 1.25f + 0.025f;
    
    ro = vec3(sin(rotPh), y, cos(rotPh)) * rad;
    vec3 lookAt = vec3(0,0,0);
    
    vec3 cf = normalize(lookAt - ro);
    vec3 cr = normalize(cross(cf, vec3(0,1,0)));
    vec3 cu = normalize(cross(cr, cf));
    const float fl = 1.f; // focal length
    rd = normalize(uv.x * cr + uv.y * cu + fl * cf); 
}

// analytical height fog based on: https://iquilezles.org/articles/fog/
#ifdef APPLY_HEIGHT_FOG
void ApplyFog(inout vec3 col, float t, vec3 ro, vec3 rd )
{
    t = max(0., t);
    const float invExt = 1. / fogHeightExtinction;
    float fogAmount = invExt * exp(-ro.y*fogHeightExtinction) * (1.0-exp(-t*rd.y*fogHeightExtinction))/rd.y;
    fogAmount *= fogIntensity;
    fogAmount *= 1. - exp(-t * fogDistExtinction);
    fogAmount = saturate(fogAmount);
    col = mix(col, fogColor, fogAmount);
}
#else
void ApplyFog(inout vec3 col, float t, vec3 ro, vec3 rd ) { return ; }
#endif

// Based on https://www.shadertoy.com/view/ssfBDf
vec4 mod289(vec4 x)
{
    return x - floor(x / 289.0) * 289.0;
}
vec4 permute(vec4 x)
{
    return mod289((x * 34.0 + 1.0) * x);
}
float causticNoiseBlur;
vec4 snoise(vec3 v)
{
    const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);

    // First corner
    vec3 i  = floor(v + dot(v, vec3(C.y)));
    vec3 x0 = v   - i + dot(i, vec3(C.x));

    // Other corners
    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min(g.xyz, l.zxy);
    vec3 i2 = max(g.xyz, l.zxy);

    vec3 x1 = x0 - i1 + C.x;
    vec3 x2 = x0 - i2 + C.y;
    vec3 x3 = x0 - 0.5;

    // Permutations
    vec4 p =
      permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0))
                            + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                            + i.x + vec4(0.0, i1.x, i2.x, 1.0));

    // Gradients: 7x7 points over a square, mapped onto an octahedron.
    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
    vec4 j = p - 49.0 * floor(p / 49.0);  // mod(p,7*7)

    vec4 x_ = floor(j / 7.0);
    vec4 y_ = floor(j - 7.0 * x_); 

    vec4 x = (x_ * 2.0 + 0.5) / 7.0 - 1.0;
    vec4 y = (y_ * 2.0 + 0.5) / 7.0 - 1.0;

    vec4 h = 1.0 - abs(x) - abs(y);

    vec4 b0 = vec4(x.xy, y.xy);
    vec4 b1 = vec4(x.zw, y.zw);

    vec4 s0 = floor(b0) * 2.0 + 1.0;
    vec4 s1 = floor(b1) * 2.0 + 1.0;
    vec4 sh = -step(h, vec4(0.0));

    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;

    vec3 g0 = vec3(a0.xy, h.x);
    vec3 g1 = vec3(a0.zw, h.y);
    vec3 g2 = vec3(a1.xy, h.z);
    vec3 g3 = vec3(a1.zw, h.w);

    // Compute noise and gradient at P
    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);
    vec4 m2 = m * m;
    vec4 m3 = m2 * m;
    vec4 m4 = m2 * m2;
    vec3 grad =
      -6.0 * m3.x * x0 * dot(x0, g0) + m4.x * g0 +
      -6.0 * m3.y * x1 * dot(x1, g1) + m4.y * g1 +
      -6.0 * m3.z * x2 * dot(x2, g2) + m4.z * g2 +
      -6.0 * m3.w * x3 * dot(x3, g3) + m4.w * g3;
    vec4 px = vec4(dot(x0, g0), dot(x1, g1), dot(x2, g2), dot(x3, g3));
    return mix(42.0, 0., causticNoiseBlur) * vec4(grad, dot(m4, px));
}
